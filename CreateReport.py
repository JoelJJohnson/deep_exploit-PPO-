#!/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import codecs
import glob
import configparser
import pandas as pd
from datetime import datetime
from docopt import docopt
from jinja2 import Environment, FileSystemLoader
from util import Utilty

# Type of printing.
OK = 'ok'         # [*]
NOTE = 'note'     # [+]
FAIL = 'fail'     # [-]
WARNING = 'warn'  # [!]
NONE = 'none'     # No label.


# Create report.
class CreateReport:
    def __init__(self):
        self.util = Utilty()

        # Read config file.
        full_path = os.path.dirname(os.path.abspath(__file__))
        config = configparser.ConfigParser()
        try:
            config.read(os.path.join(full_path, 'config.ini'))
        except Exception as err:
            self.util.print_exception(err, 'File exists error')
            sys.exit(1)

        self.report_date_format = config['Report']['date_format']
        self.report_test_path = os.path.join(full_path, config['Report']['report_test'])
        self.report_test_file = os.path.join(self.report_test_path, config['Report']['report_test_file'])
        self.template_test = config['Report']['template_test']
        self.report_train_path = os.path.join(self.report_test_path, config['Report']['report_train'])
        self.report_train_file = os.path.join(self.report_train_path, config['Report']['report_train_file'])
        self.template_train = config['Report']['template_train']
        self.header_train = str(config['Report']['header_train']).split('@')
        self.header_test = str(config['Report']['header_test']).split('@')

    def create_report(self, mode='train', start_date=None, intel=None, threats=None, vulnerabilities=None, exploitation_results=None, post_exploit_data=None):
        # Check mode.
        if mode not in ['train', 'test']:
            self.util.print_message(FAIL, 'Invalid mode: {}'.format(mode))
            exit(1)

        # Gather reporting items.
        if mode == 'train':
            self.util.print_message(NOTE, 'Creating training report.')
            csv_file_list = glob.glob(os.path.join(self.report_train_path, '*.csv'))

            # Create DataFrame.
            content_list = []
            for file in csv_file_list:
                df = pd.read_csv(file, names=self.header_train, sep=',')
                df['date'] = pd.to_datetime(df['date'])
                selected_df = df[(start_date < df['date'])]
                content_list.append(selected_df)

            if len(content_list) != 0:
                df_csv = pd.concat(content_list).drop_duplicates().sort_values(by=['ip', 'port'],
                                                                               ascending=True).reset_index(drop=True,
                                                                                                           col_level=1)

                items = []
                for idx in range(len(df_csv)):
                    items.append({'ip_addr': df_csv.loc[idx, 'ip'],
                                  'port': df_csv.loc[idx, 'port'],
                                  'prod_name': df_csv.loc[idx, 'service'],
                                  'vuln_name': df_csv.loc[idx, 'vuln_name'],
                                  'description': df_csv.loc[idx, 'description'],
                                  'type': df_csv.loc[idx, 'type'],
                                  'exploit': df_csv.loc[idx, 'exploit'],
                                  'target': df_csv.loc[idx, 'target'],
                                  'payload': df_csv.loc[idx, 'payload'],
                                  'ref': str(df_csv.loc[idx, 'reference']).replace('@', '<br>')})

                try:
                    # Setting template.
                    env = Environment(loader=FileSystemLoader(self.report_train_path))
                    template = env.get_template(self.template_train)
                    pd.set_option('display.max_colwidth', -1)
                    html = template.render({'title': 'Deep Exploit Scan Report', 'items': items})

                    # Write report.
                    with codecs.open(self.report_train_file, 'w', 'utf-8') as fout:
                        fout.write(html)
                except Exception as err:
                    self.util.print_exception(err, 'Creating report error.')
            else:
                self.util.print_message(WARNING, 'Exploitation result is not found.')
            self.util.print_message(OK, 'Creating training report done.')
        else:
            self.util.print_message(NOTE, 'Creating testing report.')
            csv_file_list = glob.glob(os.path.join(self.report_test_path, '*.csv'))

            # Create DataFrame.
            content_list = []
            for file in csv_file_list:
                df = pd.read_csv(file, names=self.header_test, sep=',')
                df['date'] = pd.to_datetime(df['date'])
                selected_df = df[(start_date < df['date'])]
                content_list.append(selected_df)

            if len(content_list) != 0:
                df_csv = pd.concat(content_list).drop_duplicates().sort_values(by=['ip', 'port'],
                                                                               ascending=True).reset_index(drop=True,
                                                                                                           col_level=1)

                items = []
                for idx in range(len(df_csv)):
                    items.append({'ip_addr': df_csv.loc[idx, 'ip'],
                                  'port': df_csv.loc[idx, 'port'],
                                  'source_ip_addr': df_csv.loc[idx, 'src_ip'],
                                  'prod_name': df_csv.loc[idx, 'service'],
                                  'vuln_name': df_csv.loc[idx, 'vuln_name'],
                                  'description': df_csv.loc[idx, 'description'],
                                  'type': df_csv.loc[idx, 'type'],
                                  'exploit': df_csv.loc[idx, 'exploit'],
                                  'target': df_csv.loc[idx, 'target'],
                                  'payload': df_csv.loc[idx, 'payload'],
                                  'ref': str(df_csv.loc[idx, 'reference']).replace('@', '<br>')})

                try:
                    # Setting template.
                    env = Environment(loader=FileSystemLoader(self.report_test_path))
                    template = env.get_template(self.template_test)
                    pd.set_option('display.max_colwidth', -1)
                    
                    # Add new sections to the report
                    intel_section = self.create_intel_section(intel)
                    threat_section = self.create_threat_section(threats)
                    vuln_section = self.create_vulnerability_section(vulnerabilities)
                    exploit_section = self.create_exploitation_section(exploitation_results)
                    post_exploit_section = self.create_post_exploit_section(post_exploit_data)
                    
                    html = template.render({
                        'title': 'Deep Exploit Scan Report',
                        'items': items,
                        'intel_section': intel_section,
                        'threat_section': threat_section,
                        'vuln_section': vuln_section,
                        'exploit_section': exploit_section,
                        'post_exploit_section': post_exploit_section
                    })

                    # Write report.
                    with codecs.open(self.report_test_file, 'w', 'utf-8') as fout:
                        fout.write(html)
                except Exception as err:
                    self.util.print_exception(err, 'Creating report error.')
            else:
                self.util.print_message(WARNING, 'Exploitation result is not found.')
            self.util.print_message(OK, 'Creating testing report done.')

    def create_intel_section(self, intel):
        if not intel:
            return "No intelligence data available."
        return f"""
        <h2>Intelligence Gathering</h2>
        <h3>OS Detection</h3>
        <pre>{intel.get('os_detection', 'N/A')}</pre>
        <h3>Service Versions</h3>
        <pre>{intel.get('version_detection', 'N/A')}</pre>
        <h3>Whois Information</h3>
        <pre>{intel.get('whois', 'N/A')}</pre>
        """

    def create_threat_section(self, threats):
        if not threats:
            return "No threats identified."
        threat_list = "".join([f"<li>{threat}</li>" for threat in threats])
        return f"""
        <h2>Threat Model</h2>
        <ul>
        {threat_list}
        </ul>
        """

    def create_vulnerability_section(self, vulnerabilities):
        if not vulnerabilities:
            return "No vulnerabilities detected."
        return f"""
        <h2>Vulnerabilities</h2>
        <pre>{vulnerabilities}</pre>
        """

    def create_exploitation_section(self, exploitation_results):
        if not exploitation_results:
            return "No exploitation results available."
        result_list = "".join([f"<li>{result}</li>" for result in exploitation_results])
        return f"""
        <h2>Exploitation Results</h2>
        <ul>
        {result_list}
        </ul>
        """

    def create_post_exploit_section(self, post_exploit_data):
        if not post_exploit_data:
            return "No post-exploitation data available."
        return f"""
        <h2>Post-Exploitation Data</h2>
        <h3>System Info</h3>
        <pre>{post_exploit_data['sysinfo']}</pre>
        <h3>Processes</h3>
        <pre>{post_exploit_data.get('processes', 'N/A')}</pre>
        <h3>Privilege Escalation Attempt</h3>
        <pre>{post_exploit_data.get('priv_esc_attempt', 'N/A')}</pre>
        """


# Define command option.
__doc__ = """{f}
Usage:
    {f} (-m <mode> | --mode <mode>) [(-s <start> | --start <start>)]
    {f} -h | --help

Options:
    -m --mode     Require  : Creating mode "train/test".
    -s --start    Optional : begining start time (format='%Y%m%d%H%M%S')
    -h --help     Optional : Show this screen and exit.
""".format(f=__file__)


# Parse command arguments.
def command_parse():
    args = docopt(__doc__)
    mode = args['<mode>']
    start_time = args['<start>']
    return mode, start_time


if __name__ == '__main__':
    # Get command arguments.
    mode, start_time = command_parse()

    # Create report.
    report = CreateReport()
    try:
        if start_time is None:
            start_time = '19000101000000'
        get_date = datetime.strptime(start_time, '%Y%m%d%H%M%S')
        report.create_report(mode, pd.to_datetime(report.util.transform_date_string(get_date)))
    except Exception as err:
        report.util.print_exception(err, 'Invalid date format: {}.'.format(start_time))
        exit(1)
